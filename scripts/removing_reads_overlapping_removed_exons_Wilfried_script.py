#!/usr/bin/env python3

# -*- coding: utf-8 -*-

# Importing modules
import os
import sys
import tqdm
import gc
import argparse
import pathlib

# This function create a list of excluded exon numbers
# Input: Path to the file with read counts for exons that have been filtered out
# Output: List with exon numbers
def ExcludedExonsList(path_to_input_file):
    # Creating list to return
    list_to_return = []
    # Opening a file handle
    f = open(path_to_input_file, 'r')
    # Iterating over a file
    for line in f:
        # If line does not start with hash ('#')
        if not line.startswith('#'):
            # Split lines by tab character
            line_sep = line.strip().split('\t')
            # Obtain exon number which is a first element in splitted string
            exon_number_id = line_sep[0]
            # Append the exon number to output list
            list_to_return.append(exon_number_id)
            # Delete variables not needed anymore
            del line_sep, exon_number_id
    # Close file handle
    f.close()
    # Delete variables not needed anymore
    del f, line
    # Return list of excluded exons
    return list_to_return

# This function creates two lists with reads to include in the output file (reads not covering excluded exons) and reads covering excluded exons
# Input:
#   - path_to_file: Path to the file with reads and their splicing patterns (e.g. files generated by Wilfried ending at _splicing_patterns_cds.tmp)
#   - list_with_excluded_exons: List containing exon IDs that were filtered out
# Output: Two lists containing reads and their splicing patterns included for further analysis and reads (and their splicing patterns) that are filtered out
def SeparatingReadsCoveringExcludedExons(path_to_file, list_with_excluded_exons):
    # List with reads to be included in further analysis
    included_reads_splicing_patterns = []
    # List with removed reads
    removed_reads_splicing_patterns = []
    # Opening file handle
    f = open(path_to_file, 'r')
    # Iterating over lines of file
    for line in f:
        # Splitting line by tab character
        line_sep = line.strip().split('\t')
        # Obtaining splice pattern for the read
        # Omitting reads without splicing pattern
        try:
            read_splice_pattern_list = line_sep[1].split('_')
        except IndexError:
            print("NO SPLICING PATTERN FOR READ: %s" % (line_sep[0]))
            del line_sep
            continue
        # If status variable is true, then add to good list, else add to removed read list
        included_read_status = True
        # If there is a removed exon in a splice pattern, add stripped line to list for removed reads, if not then add a line to a list for not-filered reads
        for excluded_exon_id in list_with_excluded_exons:
            if excluded_exon_id in read_splice_pattern_list:
                included_read_status = False
                break
        # Add to good list if True, add to removed list if False
        if included_read_status:
            included_reads_splicing_patterns.append(line.strip())
        else:
            removed_reads_splicing_patterns.append(line.strip())
        # Delete variables not needed anymore
        del line_sep, read_splice_pattern_list, included_read_status, excluded_exon_id
    # Close file handle
    f.close()
    # Delete variables not needed anymore
    del f, line
    # Return list containing reads to work on further and reads to exclude
    return included_reads_splicing_patterns, removed_reads_splicing_patterns

# This function writes all lines to output file
# Input:
#   - list_with_lines: List containing all lines
#   - path_to_output_file: Path to output file to write these lines
# Output: Files with not-filtered and removed reads and their splicing patterns
def WriteOutputFiles(list_with_lines, path_to_output_file):
    # Open file handle for writing files
    g = open(path_to_output_file, 'w')
    # Creating a header
    header_to_write = '#Read_name\tExon_splice_pattern\n'
    # Writing header to file
    g.write(header_to_write)
    # Deleting header string
    del header_to_write
    # Creating string to write by joining list with lines by newline character
    string_to_write = '\n'.join(list_with_lines)
    # Adding newline char at the end of string
    string_to_write = string_to_write + '\n'
    # Writing string to the output file
    g.write(string_to_write)
    # Closing file
    g.close()
    # Removing all variables
    del string_to_write, g

if __name__ == '__main__':
    # Import the input files using argparse module
    parser = argparse.ArgumentParser(description='This script removes reads covering excluded exons.')
    parser.add_argument('in_excluded_exons', type=str, help='Path to the file with excluded exons and read counts for these exons.')
    parser.add_argument('in_splice_patterns', type=str, help='Path to the file with splice patterns for each read.')
    parser.add_argument('out_included', type=str, help='Path to the file with reads and their splice patterns for reads not covering removed exons.')
    parser.add_argument('out_removed', type=str, help='Path to the file with reads and their splice patterns for reads having removed exons in their splice patterns.')
    args = parser.parse_args()
    # List of all excluded exon IDs (exon numbers)
    excluded_exon_list = ExcludedExonsList(args.in_excluded_exons)
    # Lists having lines for files having good and filtered reads
    good_read_list, excluded_read_list = SeparatingReadsCoveringExcludedExons(args.in_splice_patterns, excluded_exon_list)
    # Writing output file with reads not covering removed exons
    WriteOutputFiles(good_read_list, args.out_included)
    # Writing output file with reads containing removed exons
    WriteOutputFiles(excluded_read_list, args.out_removed)
    # Deleting the working space variables
    del excluded_exon_list, good_read_list, excluded_read_list
    gc.collect()
